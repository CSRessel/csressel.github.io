"use strict";(self.webpackChunkpersonalpage=self.webpackChunkpersonalpage||[]).push([[3877],{931:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var a=t(5454),r=t(4848),i=t(8453);const o={slug:"python-generators-part2",title:"Learning generators part 2: In depth",authors:"csressel"},s=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Functions Internally Handling State",id:"functions-internally-handling-state",level:2},{value:"Internally Managing a State Machine with Caller-Passed Input",id:"internally-managing-a-state-machine-with-caller-passed-input",level:2},{value:"Would I Use This in Large Projects?",id:"would-i-use-this-in-large-projects",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"How generators can be used in four ways (from simple to complex):"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Lazy-like expressions, including unbounded sequences"}),"\n",(0,r.jsx)(n.li,{children:"Alternating control flow with the caller"}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:'A "pure-looking" function, with hidden internal state'})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Internally managing a state-machine, that handles caller-passed input"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The first two use cases are covered ",(0,r.jsx)(n.a,{href:"/blog/python-generators-part1",children:"this previous article"}),", and serve as a primer to the topic.\nIf you don't have a solid understanding of generators in Python, I would recommend starting there."]}),"\n",(0,r.jsx)(n.p,{children:"The second two use cases are covered in this article."}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsx)(n.p,{children:"Well that's a big gap in time between these two articles!"}),(0,r.jsx)(n.p,{children:"A peak behind the screen -- I speed wrote the first article and outlined the\nsecond, immediately after doing some small projects and consuming some related\ntech talks. This past month I was able to clean up this section, and finally\nclick publish on both!"})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"functions-internally-handling-state",children:"Functions Internally Handling State"}),"\n",(0,r.jsxs)(n.p,{children:["Both the previous use cases are common ones, made more concise through generators.\nThis use case and the next are less common use cases that are less about convenience, and more becoming ",(0,r.jsx)(n.strong,{children:"possible"})," with generators.\n(Okay okay, that's not a challenge... There are definitely other ways to construct this logic! But I think these particular formations make me thankful for the tool.)"]}),"\n",(0,r.jsx)(n.p,{children:"In a generalization from use case one, the internal state of a generator function is useful for more than just sequence-like behavior.\nAlthough the most basic case of a generator is an iterator, which lends itself to sequence-like structures, it turns out to be very useful for other logic,\nwhere some internal state that was mutated in between logical steps can now be encapsulated entirely into the function structure."}),"\n",(0,r.jsxs)(n.p,{children:['As a quick example of that "internal state," consider calculating a moving average.\nThere\'s a logical dependency between each step on all previous.\nGenerators will track solely that dependency, and leave the caller with their ',(0,r.jsx)(n.code,{children:"Iterator"})," output:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import time\nfrom collections.abc import Iterable, Iterator\nfrom typing import Union\n\ndef moving_average(data: Iterable[Union[int, float]]) -> Iterator[float]:\n    _total = 0.0\n    _count = 0\n    for item in data:\n        _total += item\n        _count += 1\n        yield _total / _count\n\n\n# To the caller, it just looks like an Iterator\nprint(list(moving_average([0, 7, 11, 8, 77])))\n\n# And the abstraction still lets the caller proceed lazily if necessary\nstart_time = time.time()\naverage = 0\n# 50 ms of moving average across some distribution\nfor average in moving_average(rand_int()):\n    if (time.time() - start_time) * 1000 > 10:\n        break\n    print(average)\n"})}),"\n",(0,r.jsx)(n.p,{children:"That's fine and well, maybe the shortest way to write that, but that only feels like a pure function if we're always casting the Iterator back to a list."}),"\n",(0,r.jsxs)(n.p,{children:["But something is missing from that code... What is the ",(0,r.jsx)(n.code,{children:"next_rand_int"})," function?\nWell I guess we want a different random number any time that function is called.\nIn fact, for a lot of randomness you might want that to be both deterministic for your application trace, and still random for all disparate callers.\nThe normal way to accomplish this is to feed the previous random as the following seed, but that requires all callers knowing if any other caller changed the seed.\nThe standard library achieves this with an instance of the ",(0,r.jsx)(n.code,{children:"random.Random"})," class, which manages state for you.\nIn that case though, it can feel like you need a singleton or mono pattern for every code trace to get access to the same object instance."]}),"\n",(0,r.jsx)(n.p,{children:"Instead, we can just encapsulate the random state in our helper function:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from random import Random\n\nMAX_RAND = 1 << 10\ndef rand_int(max_int=MAX_RAND) -> Iterator[float]:\n    r = Random(8)\n    while True:\n        yield r.random() * max_int\ndef next_rand_int(max_int=MAX_RAND) -> float:\n    return next(rand_int(max_int))\n\n# And with our previous example...\nstart_time = time.time()\nelement = 0\nfor element in moving_average(next_rand_int()):\n    if (time.time() - start_time) * 1000 > 10:\n        break\n    print(element)\n# We now see the uniform distribution here:\nassert abs(element - MAX_RAND / 2) < 1\n"})}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsxs)(n.p,{children:["It's important to note this is obviously ",(0,r.jsx)(n.strong,{children:"not"})," a truly pure function, as calling it with the same input will return different outputs.\nAs a programming paradigm though, it feels ",(0,r.jsx)(n.em,{children:"closer"})," to functional than using a singleton pattern to host a ",(0,r.jsx)(n.code,{children:"Random"}),' instance.\nWhen I before mentioned a "pure-looking function, with hidden internal state," that probably sounded oxymoronic.']}),(0,r.jsxs)(n.p,{children:['What I\'m calling "closer to functional" is maybe an implicit feeling that there is "program state," and then there is "world state," and ',(0,r.jsx)(n.strong,{children:"when functional paradigms are most helpful is when they eliminate the program state"}),".\nWhen they feel obtuse and frustrating is often when they run up against the realities of hardware and the world state."]}),(0,r.jsxs)(n.p,{children:["For several reasons, randomness feels like it belongs in that second category, alongside the system clock, runtime performance, and other realities of hardware.\nThe most pressing reason is that for a production release of your application, you may need to opaquely switch the ",(0,r.jsx)(n.code,{children:"next_rand_int"})," implementation out with a ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/List_of_random_number_generators#Random_number_generators_that_use_external_entropy",children:"platform specific implementation"}),", or even one of ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Hardware_random_number_generator",children:"extremely high entropy"}),", and that ",(0,r.jsx)(n.em,{children:"actually will be"})," reliant on world state and the realities of hardware."]})]}),"\n",(0,r.jsx)(n.p,{children:"Just to quiet the functional nerd in me (and maybe in you), here is a useful example that actually does simplify a pure function implementation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from typing import Iterable, Tuple\n\ndef run_length_encoding(data: str) -> str:\n    def grouped(i: Iterable) -> Iterable[Tuple[int, str]]:\n        iterator = iter(data)\n        try:\n            _group = next(iterator)\n            _count = 1\n        except StopIteration:\n            return\n\n        for item in iterator:\n            if item == _group:\n                _count += 1\n            else:\n                yield (_count, _group)\n                _group = item\n                _count = 1\n\n        yield (_count, _group)\n\n    groups = grouped(data)\n    return "".join(map(str, grouped(data)))\n\nprint(run_length_encoding(\n    "WWWWWWWWWWWWBW"\n    "WWWWWWWWWWWBBB"\n    "WWWWWWWWWWWWWW"\n    "WWWWWWWWWWBWWW"\n    "WWWWWWWWWWW"\n))\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"internally-managing-a-state-machine-with-caller-passed-input",children:"Internally Managing a State Machine with Caller-Passed Input"}),"\n",(0,r.jsxs)(n.p,{children:["Finally, the most general abstraction with generators is achieved when we bring in the ",(0,r.jsx)(n.code,{children:"generator.send(...)"})," functionality.\nIn other languages, this functionality is called a ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Coroutine",children:"coroutine"}),", but in Python that term is overloaded already with constructs from the ",(0,r.jsx)(n.code,{children:"asyncio"}),' module, so best to just referred to this as "generators with dot send."']}),"\n",(0,r.jsxs)(n.p,{children:["Sending is the opposite of yielding.\nWhen we use a generator, upon pausing the function frame and yielding control to the caller, we can yield some data along with that action.\nSending occurs when we resume the function frame, and along with that action we can also send along some data.\nAs a result, internal to the function implementation we could be controlling the state of the state machine, and each transition is eating some portion of the input as officiated by whatever the caller ",(0,r.jsx)(n.code,{children:".send()"}),"'s:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from typing import Any, Callable, Generator\nfrom functools import wraps\n\ndef primed_coroutine(\n    func: Callable[..., Generator[Any, Any, Any]],\n) -> Callable[..., Generator[Any, Any, Any]]:\n    @wraps(func)\n    def start(*args, **kwargs):\n        cr = func(*args, **kwargs)\n        next(cr)\n        return cr\n\n    return start\n\nConnectionState = Literal["DISCONNECTED", "CONNECTING", "CONNECTED", "ERROR"]\nConnectionEvent = Literal["connect", "connect_success", "connect_fail", "send_data", "disconnect"]\n@primed_coroutine\ndef connection_handler():\n    state: ConnectionState = "DISCONNECTED"\n    while True:\n        event: ConnectionEvent = yield state\n        print(f"State: {state}, Event: {event}")\n\n        match (state, event):\n            case ("DISCONNECTED", "connect"):\n                state = "CONNECTING"\n            case ("CONNECTING", "connect_success"):\n                state = "CONNECTED"\n            case ("CONNECTING", "connect_fail"):\n                state = "ERROR"\n                print("Connection failed, entering error state.")\n                break  # Exit the coroutine\n            case ("CONNECTING", "disconnect"):\n                state = "DISCONNECTED";\n                print("Connection failed, entering error state.")\n                break  # Exit the coroutine\n            case ("CONNECTED", "send_data"):\n                print("-> Data sent successfully.")\n            case ("CONNECTED", "disconnect"):\n                state = "DISCONNECTED"\n            case _:\n                # Default case for any unhandled state/event combination\n                print(f"-> Cannot \'{event}\' from state \'{state}\'")\n\nprint("Starting Connection Test...")\nhandler = connection_handler()\n# (The first .send(None) is handled by the decorator, so we start sending events)\ncurrent_state = handler.send("connect")\nprint(f"New state: {current_state}\\n")\ncurrent_state = handler.send("connect_success")\nprint(f"New state: {current_state}\\n")\ncurrent_state = handler.send("send_data")\nprint(f"New state: {current_state}\\n")\ncurrent_state = handler.send("disconnect")\nprint(f"New state: {current_state}\\n")\nhandler.close()\n'})}),"\n",(0,r.jsx)(n.mermaid,{value:"stateDiagram-v2\n    [*] --\x3e DISCONNECTED\n\n    DISCONNECTED --\x3e CONNECTING: connect\n    \n    CONNECTING --\x3e CONNECTED: connect_success\n    CONNECTING --\x3e ERROR: connect_fail\n    \n    CONNECTED --\x3e CONNECTED: send_data\n    CONNECTED --\x3e DISCONNECTED: disconnect\n\n    ERROR --\x3e [*]"}),"\n",(0,r.jsx)(n.p,{children:"This is a simple example that enforces permissibility of transitions, but doesn't really encapsulate any concerns from the caller yet.\nHowever, now it is an easy ask to encapsulate a state-dependent behavior that the caller doesn't have reason to know about.\nFor example, this connection handler could buffer the \"sent\" data, and then truly dispatch the network request when either reaching a buffer size threshold or upon disconnect:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from textwrap import indent\n\nConnectionState = Literal["DISCONNECTED", "CONNECTING", "CONNECTED", "ERROR"]\nConnectionEvent = Literal[\n    "connect", "connect_success", "connect_fail", "send_data", "disconnect"\n]\n\n@primed_coroutine\ndef connection_handler(\n    max_buffer_length: int = 2 ** 10,\n) -> Generator[ConnectionState, Tuple[ConnectionEvent, str | None], None]:\n    state = "DISCONNECTED"\n    buffer = bytearray()\n\n    def flush_buffer(b: bytearray) -> None:\n        print("Flushing buffer")\n        print(indent(b.decode("utf-8"), "... "))\n        b.clear()\n\n    while True:\n        event, data = yield state\n        print(f"State: {state}, Event: {event}, Data: {data.strip() if data else \'-\'}")\n\n        match (state, event, data):\n            case ("DISCONNECTED", "connect", None):\n                state = "CONNECTING"\n            case ("CONNECTING", "connect_success", None):\n                state = "CONNECTED"\n            case ("CONNECTING", "connect_fail", None):\n                state = "ERROR"\n                print("Connection failed, entering error state.")\n                break  # Exit the coroutine\n            case ("CONNECTED", "send_data", str()):\n                buffer.extend(data.encode("utf-8"))\n                if len(buffer) >= max_buffer_length:\n                    flush_buffer(buffer)\n            case ("CONNECTED", "disconnect", None):\n                if len(buffer) > 0:\n                    flush_buffer(buffer)\n                state = "DISCONNECTED"\n            case _:\n                # Default case for any unhandled state/event combination\n                print(\n                    f"-> No transition for event \'{event}\' in state \'{state}\'!"\n                    f"Potentially dropping data \'{data}\'!"\n                )\n\nprint("Starting Connection Test...")\nhandler = connection_handler(64) # Small buffer for testing\ncurrent_state = handler.send(("connect", None))\ncurrent_state = handler.send(("connect_success", None))\ncurrent_state = handler.send(("send_data", "Sphinx of black quartz, judge my vow!\\n"))\n# Nothing printed\ncurrent_state = handler.send(("send_data", "The quick brown fox jumped over the lazy dog.\\n"))\n# Both pangrams printed as the buffer is full\ncurrent_state = handler.send(("send_data", "The five boxing wizards jump quickly?\\n"))\n# Nothing printed\ncurrent_state = handler.send(("disconnect", None))\n# The buffer is flushed before disconnect\nhandler.close()\n'})}),"\n",(0,r.jsx)(n.p,{children:"Obviously this connection handler could easily be handled with an object instance, that uses instance members to manage the internal state.\nHowever, there are affordances that the object instance doesn't provide for use cases that involve concurrency."}),"\n",(0,r.jsx)(n.p,{children:"The first is when the function can unblock during work that is suitable for concurrent processing (network and file operations, generally).\nThis is extra useful in a language like Python which doesn't allow for parallel multi-threading, so the only time that concurrency is a useful speedup is when there is non-blocking IO.\nIn this use case, the caller would be somehow responsible for handling the completion interrupt and sending back over to the generator code.\nThis particular approach was critical earlier in Python history, before async await constructs were implemented.\nHowever, async await is definitely the dominant pattern now to implement non-blocking IO."}),"\n",(0,r.jsx)(n.p,{children:"However, the second use that remains is for distributed execution environments.\nThe generator can define the boundary of execution with another programmatic environment.\nFor example, imagine you're implementing a path finding algorithm with a simple robot.\nYou can send commands and receive sensor status, but the computation is inherently asynchronous.\nYou don't know how long commands will take to complete, or given the obstacles that the robot faces if they even will be completed!"}),"\n",(0,r.jsxs)(n.p,{children:["Imagine that our program is the robot's brain, with the Pythonic compute environment, and we send commands and receive statuses from the robot's compute environment, which houses its body and sense.\nIn this model, it's critical that we can suspend and resume the brain execution while the robot's compute executes.\nWith this ability, we can easily avoid busy waiting, and later in our implementation we can actually chain different generators together using a ",(0,r.jsx)(n.code,{children:"yield from"})," syntax to delegate generator execution!"]}),"\n",(0,r.jsxs)(n.p,{children:["This is all a bit too conceptual, right? Would be nice to see some code?\nThis is actually the problem set forth in the ",(0,r.jsx)(n.a,{href:"https://github.com/dutc/mazerunner-bnl-2024/blob/main/README.md",children:"DUTC mazerunner problem statement"}),", so rather than directly write some code here for you to skim past I'm leaving it to you, the reader, to jump in and try out a generator implementation yourself!\nIn addition to the problem statment, the repo includes the general scaffolding around implementation of the brain I mentioned above.\nIf you're curious about my experience grappling with this problem, or have questions about tackling it yourself, please reach out!"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"would-i-use-this-in-large-projects",children:"Would I Use This in Large Projects?"}),"\n",(0,r.jsx)(n.p,{children:"Just recently I worked on a TUI application that has both a need for yielding from asynchronous branches, and also an internal state machine that governs the application input.\nUltimately I avoided implementing generators to handle these approachs because the project is in Rust, and there isn't a good syntactic pattern to use this pause/resume approach to function evaluation in that language."}),"\n",(0,r.jsx)(n.p,{children:"However, if I had been using Python then I ultimately don't know if I would have first tackled these async functionalities with a generator based approach.\nThe async await approach is just much more well-trodden ground.\nWhile this pattern vastly simplifies several situations described above, there are several very difficult mental obstacles:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"The first/rest and rest/last modalities of how the generator and the caller know it starting, finishing, or in progress."}),"\n",(0,r.jsx)(n.li,{children:"The generator or coroutine specializes based on business logic, making it difficult to test that encapsulation."}),"\n",(0,r.jsx)(n.li,{children:"When composition of the coroutines comes into play, it's a high cognitive burden to reason about!"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"If you've followed all of the examples here, that's great! And maybe you're more ready to put this pattern in practice then I am.\nOn my side, I'm well ready to reason about generators when the boundary of the pattern is either data-less (the \"taking turns\" use-case) or unidirectional (pausing and resuming iteration or data processes).\nI may require some further iteration through architect -> regret -> revise -> refactor, before I'm ready to put the full bidirectional strength of coroutines to work!\nBut I do expect the mental model to be useful in the future."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},5454:e=>{e.exports=JSON.parse('{"permalink":"/blog/python-generators-part2","source":"@site/blog/2025-07-11-generators-in-depth-part2.md","title":"Learning generators part 2: In depth","description":"How generators can be used in four ways (from simple to complex):","date":"2025-07-11T00:00:00.000Z","tags":[],"readingTime":11.4,"hasTruncateMarker":true,"authors":[{"name":"Clifford","url":"https://github.com/CSRessel","imageURL":"/img/csressel-xs.webp","key":"csressel","page":null}],"frontMatter":{"slug":"python-generators-part2","title":"Learning generators part 2: In depth","authors":"csressel"},"unlisted":false,"prevItem":{"title":"Rock paper scissors consequentialism","permalink":"/blog/rps-consequentialism"},"nextItem":{"title":"Learning generators part 1: Basics","permalink":"/blog/python-generators-part1"}}')}}]);