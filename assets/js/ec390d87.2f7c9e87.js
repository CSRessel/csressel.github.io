"use strict";(self.webpackChunkpersonalpage=self.webpackChunkpersonalpage||[]).push([[4860],{1124:e=>{e.exports=JSON.parse('{"permalink":"/blog/python-generators-part1","source":"@site/blog/2023-12-30-generators-in-depth-part1.md","title":"Learning generators part 1: Basics","description":"How generators can be used in four ways (from simple to complex):","date":"2023-12-30T00:00:00.000Z","tags":[],"readingTime":6.5,"hasTruncateMarker":true,"authors":[{"name":"Clifford","url":"https://github.com/CSRessel","imageURL":"/img/csressel-xs.png","key":"csressel","page":null}],"frontMatter":{"slug":"python-generators-part1","title":"Learning generators part 1: Basics","authors":"csressel"},"unlisted":false,"prevItem":{"title":"Learning generators part 2: In depth","permalink":"/blog/python-generators-part2"},"nextItem":{"title":"10 minute moments","permalink":"/blog/many-minutes-few-moments"}}')},6527:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var r=t(1124),a=t(4848),i=t(8453);const o={slug:"python-generators-part1",title:"Learning generators part 1: Basics",authors:"csressel"},s=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Lazy Expressions and Unbounded Sequences",id:"lazy-expressions-and-unbounded-sequences",level:2},{value:"Alternating Control Flow With the Caller",id:"alternating-control-flow-with-the-caller",level:2}];function u(e){const n={a:"a",code:"code",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"How generators can be used in four ways (from simple to complex):"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Lazy-like expressions, including unbounded sequences"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Alternating control flow with the caller"})}),"\n",(0,a.jsx)(n.li,{children:'A "pure-looking" function, with hidden internal state'}),"\n",(0,a.jsx)(n.li,{children:"Internally managing a state-machine, that handles caller-passed input"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The first two use cases are covered in this article, and serve as a primer to the topic."}),"\n",(0,a.jsxs)(n.p,{children:["The second two use cases are covered in the ",(0,a.jsx)(n.a,{href:"/blog/python-generators-part2",children:"second part here"}),", and might provide a new applied usage for those already familiar with generators and coroutines."]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"lazy-expressions-and-unbounded-sequences",children:"Lazy Expressions and Unbounded Sequences"}),"\n",(0,a.jsx)(n.p,{children:"Users usually first experience lazy-like behavior in Python when iterating through sequences, like so:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"fizzbuzz_squares = []\n\n# Doesn't ever store 5mil elements at once:\nfor i in range(5_000_000):\n    if i ** 2 % 15 == 0:\n        fizzbuzz_squares.append(i ** 2)\n\n# Or more succinctly, with generator comprehension syntax:\nfizzbuzz_squares = list((i**2 for i in range(5_000_000) if i ** 2 % 15 == 0))\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"range"})," function is a builtin that doesn't return a generator. Instead, ",(0,a.jsx)(n.code,{children:"range()"})," uses its own class, which implements the Iterable and the Sequence protocols with a lazy design thereof.\nThis is important so that an interpreter like CPython can execute instructions more quickly using the corresponding C builtin implementation, instead of interpreting comparitively slow Python bytecode."]}),"\n",(0,a.jsxs)(n.p,{children:["However, this behavior is so useful that it is necessary to generalize it for other use csae.\nTake for example unbounded sequences, where we by necessity need laziness.\nThe ",(0,a.jsxs)(n.a,{href:"https://docs.python.org/3/library/itertools.html#itertools.count",children:[(0,a.jsx)(n.code,{children:"count"})," function from the ",(0,a.jsx)(n.code,{children:"itertools"})," module"]})," is implemented like so:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def count(start=0, step=1):\n    # count(10) --\x3e 10 11 12 13 14 ...\n    # count(2.5, 0.5) --\x3e 2.5 3.0 3.5 ...\n    n = start\n    while True:\n        yield n\n        n += step\n"})}),"\n",(0,a.jsx)(n.p,{children:"Taking this back to our Fizz Buzz snippet, we might use unbounded sequences to calculate our value without actually knowing the stop condition up front.\nFor example, to get all of the Fizz Buzz squares less than one million:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from itertools import count, takewhile\n\nmax_value = 1_000_000\nfizzbuzz_squares = []\n\nfor candidate in count():\n    squared = candidate ** 2\n    if max_value <= squared:\n        break\n    if squared % 15 == 0:\n        fizzbuzz_squares.append(squared)\n\n# Or more succinctly, with generator comprehension syntax:\nfizzbuzz_squares = list(takewhile(lambda i: i < max_value, (i ** 2 for i in count() if i ** 2 % 15 == 0)))\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Even more useful, is that if we don't know how many we need, we can remove that final ",(0,a.jsx)(n.code,{children:"list"})," construction and the entire computation remains lazily delayed.\nThis is particularly key when the incremental computation that results from your generator involves more expensive work, like network traffic or blocking access to a database.\nBy pausing and resuming stack frames with the generator, each value is only computed right as it is needed, and the work can be aborted partway through with no extra cost:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from itertools import count\nfrom time import sleep\nimport psycopg2\n\ndef expensive_queries(cursor):\n    for candidate in count():\n        cursor.execute(f"<expensive analysis query using {candidate}>")\n        sleep(10)\n        yield cursor.fetchone()\n\nconn = psycopg2.connect("dbname=test user=postgres")\ncursor = conn.cursor()\nfor result in expensive_queries(cursor):\n    if result:  # Check some behavior about result\n        print(f"Found result: {result[0]=} {result[1]=} {result[2]=} ...")\n        break\n\ncursor.close()\nconn.close()\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"alternating-control-flow-with-the-caller",children:"Alternating Control Flow With the Caller"}),"\n",(0,a.jsxs)(n.p,{children:['The next interesting use case for generators highlights the alternation with the caller of the generator.\nThis is a mechanism by which a reusable piece of code can "take turns" with the caller.\nContext managers (that whole ',(0,a.jsx)(n.code,{children:"with ... as:"})," syntax, for setup/teardown behavior) is implemented exactly this way.\nThis makes sense, as context managers are the most plain alternation of control flow possible: in my reusable code, I'll do some setup, then you do whatever you need to do, then I'll do some teardown."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from contextlib import contextmanager\nfrom typing import Generator\n\n@contextmanager\ndef simple_context() -> Generator[None, None, None]:\n  print("Setup in the generator")\n  try:\n    yield  # "Here is my calling code"\n  finally:\n    print("Teardown in the generator")\n\nwith simple_context():\n  print("Here is my calling code")\n'})}),"\n",(0,a.jsxs)(n.p,{children:["A further generalization of this control alternation includes taking multiple turns with the caller.\nThis way the caller can complete any individualized logic that would otherwise need extra modalities baked into the reusable code.\nThis use case is extensively taught by James Powell in some of his tech talks on generators, so I'll just extend ",(0,a.jsx)(n.a,{href:"https://www.youtube.com/watch?v=JasPrZqImxo",children:"one of his examples"})," (based on 13:50):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from typing import Generator\nfrom logging import getLogger\n\nlogger = getLogger(__name__)\n\n# All output implementations send the same result:\n#\n# New York        150,000\n# London      (    50,000)\n# Tokyo           120,000\n# Berlin                -\n# Shanghai        210,000\n\ndef send_email(lines: str) -> None: pass  # Implementation not relevant\n\n# ----\n# This is awful to modify,\n# awful to test each modality for regression,\n# and the testing gets even worse when\n# you think about combinations thereof\ndef output_modal(\n    markets,\n    filename=None,\n    to_log=False,\n    to_email=False,\n    accounting=False,\n) -> None:\n    align = max(map(len, markets))\n\n    if to_email:\n        lines = []\n\n    for region, profit in markets.items():\n        if accounting:\n            if profit < 0:\n                profit = "({:>10,})".format(-profit)\n            elif profit > 0:\n                profit = " {:>10,}".format(profit)\n            else:\n                profit = " {:>10}".format("-")\n\n        line = "{region:<{align}}    {profit}".format(\n            region=region, profit=profit, align=align\n        )\n\n        if filename:\n            with open(filename) as f:\n                f.write(line)\n        if to_email:\n            lines.append(line)\n        if to_log:\n            logger.info(line)\n        print(line)\n\n    if to_email:\n        send_email("\\n".join(lines))\n\n# ----\n# Functional programming inversion of modal control on just the formatting\ntemplate = "{region:<{align}}    {profit}".format\ndef accounting(p) -> str:\n    # Here\'s where "Pythonic" approaches are unreadable BS imo:\n    # return {1: " {:10,}", -1: "({:>10,})", 0: " {:>10}".format("-")}[(p > 0) - (p < 0)].format(abs(p))\n\n    match (p > 0, p < 0):\n        # Structural pattern matching is good as of 3.10, use it!\n        case (True, False):\n            return " {:10,}".format(p)\n        case (False, True):\n            return "({:>10,})".format(-p)\n        case _:\n            return " {:>10}".format("-")\ndef output_functional(\n    markets,\n    write=print,\n    template=template,\n    accounting=accounting,\n) -> None:\n    align = max(map(len, markets))\n    for region, profit in markets.items():\n        write(template(region=region, profit=accounting(profit), align=align))\n\n# ----\n# Even better yet, invert more modal control on the output using generators\ndef output_generators(\n    markets,\n    template=template,\n    accounting=accounting,\n) -> Generator[str, None, None]:\n    align = max(map(len, markets))\n    for region, profit in markets.items():\n        line = template(region=region, profit=accounting(profit), align=align)\n        yield line\n\n\nif __name__ == "__main__":\n    markets_data = {\n        "New York": 150000,\n        "London": -50000,\n        "Tokyo": 120000,\n        "Berlin": 0,\n        "Shanghai": 210000,\n    }\n\n    # Output modal is a monstrosity internally to read and maintain\n    output_modal(\n        markets_data,\n        to_log=True,\n        to_email=True,\n        accounting=True,\n    )\n\n    # Even though output with functional style is easier to maintain,\n    # it\'s still harder to call:\n    email_lines = []\n    write_log = logger.info\n    write_email = email_lines.append\n    output_functional(markets_data, write=print)\n    output_functional(markets_data, write=write_log)\n    output_functional(markets_data, write=write_email)\n    send_email("\\n".join(email_lines))\n\n    # Whereas output with generators is much cleaner:\n    email_lines = []\n    for line in output_generators(markets_data):\n        print(line)\n        logger.info(line)\n    send_email("\\n".join(email_lines))\n'})}),"\n",(0,a.jsx)(n.p,{children:"While my preferences usually lean toward a functional approach, the generators have additional advantages.\nThe generator approach is shorter, and I would argue significantly clearer, because all necessary context about the output modalities is correctly placed with the calling code.\nThe maintainability is also improved, as formatting changes only touch the formatting functions, data structure changes only touch the function internals, and output interface changes are in one place with the caller."}),"\n",(0,a.jsxs)(n.p,{children:['Additionally, the generators can also have a different or better runtime profile over the functional one, during scenarios where the number of alternations is very high (since each "turn taking" step alternates between pre-existing function frames that are paused and resumed instead of creating and destroying them repeatedly).\nJust be warned, this isn\'t unilaterally true, as there is additional overhead for constructing the ',(0,a.jsx)(n.code,{children:"Generator"})," object, which a function call does not incur."]}),"\n",(0,a.jsxs)(n.p,{children:["Those topics, Lazy-like expressions and sequences and control flow alternation, was about where my understanding of generators stopped until recently. The ",(0,a.jsx)(n.a,{href:"/blog/python-generators-part2",children:"second part of this article"})," may introduce one or two new code abstractions for your toolbox, as it did for me!"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}}}]);