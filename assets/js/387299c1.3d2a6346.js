"use strict";(self.webpackChunkpersonalpage=self.webpackChunkpersonalpage||[]).push([[2195],{3214:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"permalink":"/blog/drawing-monospace-text","source":"@site/blog/2026-01-26-drawing-monospace-text.md","title":"\\"Drawing a monospace terminal display is straightforward.\\"","description":"Computers have used digital screens to render monospace text since at least as early as 1963, with the Teletype Model 33.","date":"2026-01-26T00:00:00.000Z","tags":[],"readingTime":12.52,"hasTruncateMarker":false,"authors":[{"name":"Clifford","url":"https://github.com/CSRessel","imageURL":"/img/csressel-xs.webp","key":"csressel","page":null}],"frontMatter":{"slug":"drawing-monospace-text","title":"\\"Drawing a monospace terminal display is straightforward.\\"","authors":"csressel","unlisted":true},"unlisted":true}');var i=n(4848),a=n(8453);const s={slug:"drawing-monospace-text",title:'"Drawing a monospace terminal display is straightforward."',authors:"csressel",unlisted:!0},o='"Drawing a monospace terminal display is straightforward."',l={authorsImageUrls:[void 0]},h=[{value:"Speed of light (text) in the terminal",id:"speed-of-light-text-in-the-terminal",level:2},{value:"The new architecture",id:"the-new-architecture",level:2},{value:"A retained mode renderer?",id:"a-retained-mode-renderer",level:3},{value:"Let history be history",id:"let-history-be-history",level:3},{value:"Non-pessimization of the requirements",id:"non-pessimization-of-the-requirements",level:3},{value:"Some takeaways",id:"some-takeaways",level:2},{value:"P.S., the <strong>Nori</strong> Approach",id:"ps-the-nori-approach",level:2},{value:"Appendix 1: Emulator Throughput",id:"appendix-1-emulator-throughput",level:2}];function c(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Computers have used digital screens to render monospace text since at least as early as 1963, with the Teletype Model 33.\nTerminals both then and now use a monospace text layout that drastically simplifies some of the toughest problems in text rendering.\nEven with all the extensions on some modern terminals, the styling is heavily constrained and the layout and shaping is mostly trivial compared to web browsers or native apps."}),"\n",(0,i.jsx)(t.p,{children:"Given these expectations for terminal applications, there was consternation online when details on the Claude Code rendering were described in these terms:"}),"\n",(0,i.jsxs)(t.div,{children:[(0,i.jsx)(t.p,{children:'Most people\'s mental model of Claude Code is that "it\'s just a TUI" but it should really be closer to "a small game engine".'}),(0,i.jsx)(t.p,{children:"For each frame our pipeline constructs a scene graph with React then\n-> layouts elements\n-> rasterizes them to a 2d screen\n-> diffs that against the previous screen\n-> finally uses the diff to generate ANSI sequences to draw"}),(0,i.jsx)(t.p,{children:"We have a ~16ms frame budget so we have roughly ~5ms to go from the React scene graph to ANSI written."}),(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://xcancel.com/trq212/status/2014051501786931427",children:"- Thariq Shihipar"})})]}),"\n",(0,i.jsx)(t.p,{children:"Responses ranged widely in severity, but had a similar message."}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Sometimes, developers get hyper-focused on tackling the immediate technical challenges in front of them that it prevents them from reflecting on past decisions.\nIt's like you take a fork in a road, and find you need to climb a mountain.\nThe faster route to your destination may be to backtrack, and take a more direct route without a mountain in the way...\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://xcancel.com/willmcgugan/status/2014341532338606480",children:"- Will McGugan"})}),"\n"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"...It's one of the worst technical things I've ever heard, posted with a straight face...\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://xcancel.com/Jonathan_Blow/status/2014920254926029179",children:"- Jonathan Blow"})}),"\n"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"We apparently live in the clown universe, where a simple TUI is driven by React and takes 11ms to lay out a few boxes and monospaced text...\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://xcancel.com/its_bvisness/status/2014381220214309042",children:"- Ben Visness"})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"And maybe the only joke I thought was actually in good taste:"}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Layout 0.9ms<br/>\nRasterization 2.1ms<br/>\nDiffing 1.2ms<br/>\nBuilding the React scene graph 11.0ms<br/>\nGenerating ANSI sequences 0.8ms<br/>\n\nsomeone who is good at the computer please help me budget this. my small game engine is dying\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://xcancel.com/barrowfaustus/status/2014270514550730867",children:"- barrowfaustus"})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Some people really get off on being smug and critical on the internet, but the Claude Code team has been navigating this problem space for months.\nLet's see what there is to learn if we think about the tradeoffs and limitations that they're working with, instead of coming in with another dunk (React hahaha amirite).\nBefore we start reference some relative comparison points (React vs Ratatui, garbage collected vs not), lets start off with some more absolute estimates for this type of workload, and why the rebuild around diff-based rendering makes sense."}),"\n",(0,i.jsx)(t.h2,{id:"speed-of-light-text-in-the-terminal",children:"Speed of light (text) in the terminal"}),"\n",(0,i.jsxs)(t.p,{children:['Any terminal interface is fundamentally limited by two things. When the virtual terminal emulator (iterm2, ghostty, VSCode integrated terminal, etc) runs your program, a bidirectional communication channel is opened with a "master" end (the emulator, whatever program your user sees) and the "slave" end (the process group, whatever program you built for the user).',(0,i.jsx)(t.sup,{children:(0,i.jsx)(t.a,{href:"#user-content-fn-1-41295c",id:"user-content-fnref-1-41295c","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})," The emulator-to-process direction of this communication is called ",(0,i.jsx)(t.code,{children:"stdin"}),", and the process-to-emulator direction of this communication is actually two channels, called ",(0,i.jsx)(t.code,{children:"stdout"})," and ",(0,i.jsx)(t.code,{children:"stderr"}),", and all of these are byte streams containing a mix of Unicode, ANSI escape sequences,  newer and rarer terminal protocol escape sequences.\nBased on this entire setup, the two limits on the speed of your interface are:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["How fast can your program process and respond to new data? Including ",(0,i.jsx)(t.code,{children:"STDIN"})," data like key presses and window resizes, or other data like reading files, network responses, and subprocess results."]}),"\n",(0,i.jsxs)(t.li,{children:["How fast can everything that is ",(0,i.jsx)(t.em,{children:"not"}),' your program, mainly the emulator on the other end, receive and render your output bytestream? Technically the pty communication itself also falls into the "not your program" category and also includes some work (like the line discipline or context switches), but this is nowhere close to the emulator\'s own bottleneck.']}),"\n"]}),"\n",(0,i.jsxs)(t.admonition,{type:"tip",children:[(0,i.jsx)(t.p,{children:"Did you know there's an actual hard limit on how many terminal interfaces you can have open?! From the Linux pty manpage:"}),(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"$ man pty\n...\nThe Linux kernel imposes a limit on the number of available UNIX 98 pseudoterminals.  Up to and including Linux 2.6.3, this limit is configured at kernel compilation time (CONFIG_UNIX98_PTYS), and the permitted number of pseudoterminals can be up to 2048, with a default setting of 256.  Since Linux 2.6.4, the limit is dynamically adjustable via /proc/sys/kernel/pty/max, and a corresponding file, /proc/sys/kernel/pty/nr, indicates how many pseudoterminals are currently in use.  For further details on these two files, see proc(5)."}),"\n"]})]}),"\n",(0,i.jsxs)(t.p,{children:["Time for some napkin math.\nImagine we want to rerender as many lines of history as possible -- what limits should we expect the bottleneck in the emulator to impose on us? Looking at one of my chats, a 150,000 token chat history contains about 53KB of printed text. That many tokens would be almost a MB of text, but the majority of that context are the thinking tokens (not shown) and the tool calls (truncated), so it's much less. However, not shown in the raw 53KB of text are the escape codes for colors, bold or dim, and ANSI codes for movement and clearing and printing, which could conceivably double or triple the size in raw bytes.",(0,i.jsx)(t.sup,{children:(0,i.jsx)(t.a,{href:"#user-content-fn-2-41295c",id:"user-content-fnref-2-41295c","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})})," So we're looking at something in the low hundreds of KB across the pty connection, for the size of each frame of full history render. Assuming a 60 FPS experience, we're looking at ~10MB per second (for example, when an active and updating history cell is just off screen)"]}),"\n",(0,i.jsxs)(t.p,{children:["So how close is this ask on paper to the theoretical max throughput of the emulator? Using the ",(0,i.jsx)(t.a,{href:"https://github.com/cmuratori/termbench",children:"cmuratori/termbench"})," repo, I can compare a few terminals' max throughput on colored text.^[Appendix 1: Detailed Results]\nTo summarize the results (appended below), the several GPU-accelerated terminal emulators on my laptop show throughput around ~50MB/s. Non-GPU-accelerated terminals (that instead allow synchronous frame drops) show the same throughput. The similarity between the two is unsurprising, as we should expect the ANSI parsing to be a mostly single core CPU-bound process (tracking the state machine of ANSI codes). However, on a virtual terminal ttyN that uses more minimal device drivers, no GPU acceleration, and no logic for synchronous frame drops, we see the legacy bottleneck: just over 100KB/s. Not per frame, per ",(0,i.jsx)(t.em,{children:"second"}),". The built-in terminal versus GPU accelerated terminal on my Mac Mini shows another, smaller performance gap: 30MB/s versus 65MB/s."]}),"\n",(0,i.jsxs)(t.p,{children:["So the napkin math doesn't fully preclude the possibility of a full history rerender for newer setups! But it does indicate the ask will be impossible on some legacy terminal emulators or very old hardware, and it will introduce frame drops and brief flickers on all but the most optimized setups. And the important understanding here is that these limitations are ",(0,i.jsx)(t.em,{children:"completely absent any particular architecture choices of the program itself"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"the-new-architecture",children:"The new architecture"}),"\n",(0,i.jsx)(t.h3,{id:"a-retained-mode-renderer",children:"A retained mode renderer?"}),"\n",(0,i.jsxs)(t.p,{children:["The details of the new architecture solve this throughput issue. Rather than forcing entire documents down the pty bottleneck, the new architecture implements the terminal equivalent of a retained mode interface.\nThe emulator retains the screen state between frames, and the program is expected to push down only the minimal ANSI codes to move the cursor (",(0,i.jsx)(t.code,{children:"CUP"}),") and update specific cells.\nAnyone familiar with the Ratatui library knows this pattern. The application ",(0,i.jsx)(t.em,{children:"describes"})," the UI every frame, but the library only ",(0,i.jsx)(t.em,{children:"transmits"})," the changes."]}),"\n",(0,i.jsx)(t.p,{children:"This solves a completely different issue than the React Virtual DOM."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"On the Web:"})," DOM updates are slow, so we use VDOM to minimize ",(0,i.jsx)(t.em,{children:"browser repaints"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"In the Terminal:"})," The byte stream is fast, but the ",(0,i.jsx)(t.em,{children:"parsing"})," is the bottleneck."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:'By treating the terminal as a grid of cells rather than a tree of objects, the terminal avoids any "parser jitter."\nHowever, implementing this inside a React-like framework means they are using a nested object tree.\nNot only is this algorithmically more distant from the text grid, it is still creating tens of thousands of short-lived objects per frame to represent that grid of characters.\nThe new design has fixed the I/O bottleneck, but they likely increased the garbage collection (GC) pressure, moving the accidental complexity elsewhere.'}),"\n",(0,i.jsx)(t.p,{children:"This leaves us with the remaining, more permanent issue that Claude Code is now dealing with: fighting the framework."}),"\n",(0,i.jsx)(t.h3,{id:"let-history-be-history",children:"Let history be history"}),"\n",(0,i.jsx)(t.p,{children:"Terminal emulators are optimized for two distinct scenarios."}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"The Scrollback"}),": the program turns information over to the emulator to own.\nImmutably, fast, and forgotten by the program.\nThe pty line discipline has modes that even optimize this case for direct copyover of plain Unicode data."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"The Viewport"}),": information fully owned by the app.\nInteractive, temporary, easily customized UI, dynamic rewraps.\nThe altscreen mode offers a separate buffer, fully controlled by the foreground progress (like neovim).\nLimited height viewports can also be implemented below the history (like ",(0,i.jsx)(t.code,{children:"fzf --inline"}),")."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Claude Code has decided to violate this contract. It demands to treat the ",(0,i.jsx)(t.em,{children:"entire"})," scrollback as a reactive viewport.\nOstensibly, there are some benefits: native search (cmd-F or similar), native text selection, native clipboard interactions, or even a long list of more complex multiplexer features.\nBut the cost is fragility."]}),"\n",(0,i.jsxs)(t.p,{children:['When the context gets too long, Claude "compacts" the history.\nIn doing so, it often clears the ',(0,i.jsx)(t.em,{children:"entire"}),' terminal scrollback, including history from before the Claude Code session!\nAny failure scenario with "fake fullscreen" that rewrites history instead of using the altscreen buffer (like ctrl+o extended output), risks leaving behind a broken scrollback that you can\'t reference or copy from.\nThe most convenient feature is history rewrapping on window resize, and that is gone the moment you exit the program, leaving you with the static history artifact that you were briefly told not to settle for!']}),"\n",(0,i.jsx)(t.h3,{id:"non-pessimization-of-the-requirements",children:"Non-pessimization of the requirements"}),"\n",(0,i.jsxs)(t.p,{children:["There's an attempt here to support an ambitious set of requirements, and I applaud the Claude Code team for trying out a new approach.\nHowever, every one of the tradeoffs I just described around fragility and fighting the emulator is just not my preference as a user.\nIf I want a scrollable dynamic interface, there is altscreen.\nIf I want a dynamic viewport below longer history, there are normal ",(0,i.jsx)(t.code,{children:"stdout"})," conventions (like fzf inline).\nIf I need the rewrapped history, I can ",(0,i.jsx)(t.code,{children:"/resume"})," the conversation in a new window.\nHeck, even introducing a separate ",(0,i.jsx)(t.code,{children:"/rewrap"})," command would make me happier than a system that constantly fights the terminal emulator for custody of the pixels."]}),"\n",(0,i.jsx)(t.p,{children:"I've found that OpenAI struck a better balance with the Codex CLI design: a double-buffered history for active vs completed cells.\nIt brings Ratatui performance with diff-based rendering for free, zero-overhead thread safety, and the raw speed of a non-GC compiled language."}),"\n",(0,i.jsx)(t.p,{children:"Full disclosure (see plug at the end!) I've been working on a distant fork of the Codex architecture to wrap the Claude agent and other agent choices. It feels nice using Opus 4.5 without flicker, stuttering, artifacts, or my terminal history getting cleared!"}),"\n",(0,i.jsx)(t.h2,{id:"some-takeaways",children:"Some takeaways"}),"\n",(0,i.jsx)(t.p,{children:"Based on these tidbits from the Claude Code team, I imagine they now have the full diff-based TUI rendering engine built out in TypeScript.\nI don't know in which areas it's at feature parity, superiority, or inferiority with similar frameworks like Ratatui.\nBut having seen the general shape and complexity of code that goes into Ratatui, and it is unambiguously a great win for the Claude Code team to deliver their own diff-based engine.\nDespite the immature reactions online, this was definitely a net positive for Claude Code, and puts them much closer to my performance expectations for a cutting-edge TUI.\nWhile I consider the requirements they've inflicted on themselves to be not my personal cup of tea, I appreciate them experimenting with the limitations of interactivity in the terminal."}),"\n",(0,i.jsx)(t.p,{children:"There are a few takeaways I'm left with, if I had to offer my remaining 5c (ontop of the 95c above):"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Why fight the framework:"})," Every feature that modifies history risks destroying it.\nTerminal users have learned to trust their scrollback as immutable log, and I personally don't like when programs break that trust."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Accidental complexity moves elsewhere:"})," I still question if rendering a text grid via an object tree (DOM/React) is appropriate for an ANSI terminal.\nIn a long history, creating or destorying thousands of node objects can easily cause a GC pause, and a frame drop may exhibit a blank screen or partially drawn UI -- more flicker!"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Language tradeoffs:"}),' Interpreted languages often justify the performance hit with "portability."\nBut in the terminal, the "non-standard environments" (Windows, old Unix distros, Android devices, etc) are ',(0,i.jsx)(t.em,{children:"exactly"})," where you need the fastest performance, because these are the slowest emulators!"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Despite the improvements to their architecture, I can't say I would lean on a GC interpreted language like JS for this type of work.\nClearly they are thinking about some of these concerns, given the acquisition of Bun.\nAnd clearly they are undeterred by the risks, given... The acquisition of Bun.\nI'm impressed by the lifespan of the Bun project to date, and it will be interesting to see what their next chapter within Anthropic looks like.\nSpecifically for Claude Code though (given the many alternative routes, with either languages or requirements), this feels like buying more RAM because your program has a memory leak.\nI have to imagine it goes beyond one product team though, and they see a broader applicability to their engineering portfolio, where higher-performance JavaScript runtimes will be necessary in the future."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsxs)(t.h2,{id:"ps-the-nori-approach",children:["P.S., the ",(0,i.jsx)(t.strong,{children:"Nori"})," Approach"]}),"\n",(0,i.jsxs)(t.p,{children:["If you're interested in these topics, or just want a terminal agent that doesn't flicker, check out the work we're doing at ",(0,i.jsx)(t.strong,{children:"Tilework"}),"!"]}),"\n",(0,i.jsxs)(t.p,{children:["Our ",(0,i.jsx)(t.strong,{children:"Nori CLI"})," is a distant fork of that performant Codex architecture, built on the philosophy that tools should be fast, intuitive, and respect your terminal's native behavior.\nWe're working on building the things that make us faster at building the things that make us faster, and tools like this are part of our long term vision to help developers fully own (and enjoy) their own toolbox."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"appendix-1-emulator-throughput",children:"Appendix 1: Emulator Throughput"}),"\n","\n",(0,i.jsxs)(t.section,{"data-footnotes":!0,className:"footnotes",children:[(0,i.jsx)(t.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{id:"user-content-fn-1-41295c",children:["\n",(0,i.jsxs)(t.p,{children:["These are the historical terms used throughout the Unix documentation. I personally find these terms completely unhelpful to remember what the responsibilities here are, so for this user interface centric discussion I'm just referring to the emulator and process group respectively. ",(0,i.jsx)(t.a,{href:"#user-content-fnref-1-41295c","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{id:"user-content-fn-2-41295c",children:["\n",(0,i.jsxs)(t.p,{children:['If you think this is unlikely, see: "napkin math". ',(0,i.jsx)(t.a,{href:"#user-content-fnref-2-41295c","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);