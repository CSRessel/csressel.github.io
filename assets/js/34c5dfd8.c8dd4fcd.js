"use strict";(self.webpackChunkpersonalpage=self.webpackChunkpersonalpage||[]).push([[9024],{4608:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"permalink":"/blog/agent-is-not-specific","source":"@site/blog/2025-10-26-agent-is-not-specific.md","title":"\\"Agent\\" is a Terribly Non-Specific Term","description":"While there\'s still a chance to throw more terminology at the wall, I think we could do better.","date":"2025-10-26T00:00:00.000Z","tags":[],"readingTime":2.81,"hasTruncateMarker":false,"authors":[{"name":"Clifford","url":"https://github.com/CSRessel","imageURL":"/img/csressel-xs.webp","key":"csressel","page":null}],"frontMatter":{"slug":"agent-is-not-specific","title":"\\"Agent\\" is a Terribly Non-Specific Term","authors":"csressel","unlisted":true},"unlisted":true}');var i=n(4848),s=n(8453);const r={slug:"agent-is-not-specific",title:'"Agent" is a Terribly Non-Specific Term',authors:"csressel",unlisted:!0},a=void 0,l={authorsImageUrls:[void 0]},c=[];function h(e){const t={a:"a",code:"code",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"While there's still a chance to throw more terminology at the wall, I think we could do better."}),"\n",(0,i.jsx)(t.p,{children:'I think that there are more specific names for these applications of generative AI. Not only are more specific names possible, they are very useful when communicating between engineers, or coming up with useful specifications for projects. Imagine that every time you wanted to deploy software in 2015, another engineer on your team asked if it was going to "the cloud." Not asking if it\'s going into a Docker container, or running on bare metal on EC2, or using that new tool "kubernetes," but literally asked "hey have you gone to the cloud yet." It would be pretty difficult to have a meaningful engineering conversation about what you\'ve implemented.'}),"\n",(0,i.jsxs)(t.p,{children:['That\'s the way I feel about the word "agent."\n',(0,i.jsx)(t.strong,{children:"Particularly in engineer-to-engineer conversations."}),'\nSo far the only commonality I\'ve seen in the definition of "agent" has been: "thing I trust at least a little bit to do something."\nIt\'s essentially a definition by absentia; if it does anything more than just spit text back at you, call it an agent.\nAs a result, when engineers and founders use this term in a technical context it doesn\'t exactly make anything more clear for me.']}),"\n",(0,i.jsxs)(t.p,{children:['Here\'s an example of how this could be done better: so-called "coding agents" like Claude Code and Cursor and the rest could be much better termed ',(0,i.jsx)(t.strong,{children:"RETLs: read eval tool loops"}),". This is obviously based on a REPL, which is a read eval print loop. However, in this use case the order of operations is:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Read"}),": user input, previous outputs, MCP for tools, etc; add anything to the prompt or context"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Eval"}),": model inference"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Tool"}),": if the result declares a tool then call it"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Loop"}),": if we haven't declared completion then go to the start"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:'These RETL tools are often put in the category of "synchronous agentic coding." Likewise, there will need to be terminology for architectures in the asynchronous category. In the agentic coding space, these would be the products currently explored by Devin and Factory and similar.'}),"\n",(0,i.jsxs)(t.p,{children:["I've noticed that this second model is architecturally very similar to ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Coroutine",children:"coroutines"}),", where each model is a program, and the suspend/resume is determined by explicit delegation of control to a model, which can ",(0,i.jsx)(t.code,{children:"yield"})," back to the caller, or ",(0,i.jsx)(t.code,{children:"yield from"})," another model or models (or \"sub-agents\"... there's that word again!), or lastly can use another model in a blocking manner.\nBut I'm not the one with the frame of reference to name things in that space, and I certainly don't know the ins and outs of useful terminology that was already termed in the AI research world, like multi-agent systems, agent-based model, ACTOR model, etc."]}),"\n",(0,i.jsxs)(t.p,{children:["However, after working pretty extensively with ",(0,i.jsx)(t.a,{href:"https://opencode.ai/",children:"OpenCode"})," (both as a power user and also to rewrite parts of the tool for my own use) I've noticed that the confines of a very common architectural pattern has emerged around the RETL definition above.\nThe RETL definition isn't a common trend within the flurry of agentive product releases this year, it's both the necessary and the complete set of behaviors that describe these products!\nAdmittedly for a broad definition of \"tool,\" that encompasses MCP servers and sub-RETLs both."]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);