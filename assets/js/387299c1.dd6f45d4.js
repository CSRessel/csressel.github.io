"use strict";(self.webpackChunkpersonalpage=self.webpackChunkpersonalpage||[]).push([[2195],{3214:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"permalink":"/blog/drawing-monospace-text","source":"@site/blog/2026-01-26-drawing-monospace-text.md","title":"Isn\'t drawing a monospace terminal display straightforward?","description":"Anthropic is a frontier AI laboratory valued at billions of dollars, and the effective \\"winner\\" of 2025 when it comes to agentic coding tools. So why do they struggle so much with rendering monospace text?","date":"2026-01-26T00:00:00.000Z","tags":[],"readingTime":16.15,"hasTruncateMarker":true,"authors":[{"name":"Clifford","url":"https://github.com/CSRessel","imageURL":"/img/csressel-xs.webp","key":"csressel","page":null}],"frontMatter":{"slug":"drawing-monospace-text","title":"Isn\'t drawing a monospace terminal display straightforward?","authors":"csressel","unlisted":true},"unlisted":true}');var i=n(4848),s=n(8453);const o={slug:"drawing-monospace-text",title:"Isn't drawing a monospace terminal display straightforward?",authors:"csressel",unlisted:!0},a="Isn't drawing a monospace terminal display straightforward?",h={authorsImageUrls:[void 0]},l=[{value:"Speed of light (text) in the terminal",id:"speed-of-light-text-in-the-terminal",level:2},{value:"The new architecture",id:"the-new-architecture",level:2},{value:"A retained mode renderer",id:"a-retained-mode-renderer",level:3},{value:"Let history be history",id:"let-history-be-history",level:3},{value:"Non-pessimization of the requirements",id:"non-pessimization-of-the-requirements",level:3},{value:"Some takeaways",id:"some-takeaways",level:2},{value:"P.S., the <strong>Nori</strong> Approach",id:"ps-the-nori-approach",level:2},{value:"Appendix: Emulator Throughput",id:"appendix-emulator-throughput",level:2}];function d(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:'Anthropic is a frontier AI laboratory valued at billions of dollars, and the effective "winner" of 2025 when it comes to agentic coding tools. So why do they struggle so much with rendering monospace text?'}),"\n",(0,i.jsx)(t.p,{children:"Terminal interfaces, from teletypewriters using paper all the way up to modern screens and GPU-accelerated emulators, simply print out a monospace text grid.\nThis completely obviates some of the toughest problems in text rendering: you often have a single font, the styling is heavily constrained, and the layout and shaping is trivial compared to web browsers or native apps.\nIn the words of Casey Muratori:"}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["Drawing a monospace terminal display is straightforward....",(0,i.jsx)("br",{}),"\n[Technical description of 8 sentences for the full rendering pipeline.]",(0,i.jsx)("br",{}),"\n...That's it, right? I mean that is the entire renderer."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Given these expectations for terminals, there was consternation from devs when details surfaced on X about the Claude Code rendering architecture:"}),"\n",(0,i.jsxs)(t.admonition,{type:"twitter",children:[(0,i.jsx)(t.p,{children:'Most people\'s mental model of Claude Code is that "it\'s just a TUI" but it should really be closer to "a small game engine".'}),(0,i.jsxs)(t.p,{children:["For each frame our pipeline constructs a scene graph with React then",(0,i.jsx)("br",{}),"\n-> layouts elements",(0,i.jsx)("br",{}),"\n-> rasterizes them to a 2d screen",(0,i.jsx)("br",{}),"\n-> diffs that against the previous screen",(0,i.jsx)("br",{}),"\n-> finally uses the diff to generate ANSI sequences to draw",(0,i.jsx)("br",{})]}),(0,i.jsx)(t.p,{children:"We have a ~16ms frame budget so we have roughly ~5ms to go from the React scene graph to ANSI written."}),(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://xcancel.com/trq212/status/2014051501786931427",children:"- Thariq Shihipar"})})]}),"\n",(0,i.jsx)(t.p,{children:"Responses ranged widely in tone, but shared a similar message."}),"\n",(0,i.jsxs)(t.admonition,{type:"twitter",children:[(0,i.jsx)(t.p,{children:"...It's one of the worst technical things I've ever heard, posted with a straight face..."}),(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://xcancel.com/Jonathan_Blow/status/2014920254926029179",children:"- Jonathan Blow"})})]}),"\n",(0,i.jsxs)(t.admonition,{type:"twitter",children:[(0,i.jsx)(t.p,{children:"Sometimes, developers get hyper-focused on tackling the immediate technical challenges in front of them that it prevents them from reflecting on past decisions.\nIt's like you take a fork in a road, and find you need to climb a mountain.\nThe faster route to your destination may be to backtrack, and take a more direct route without a mountain in the way..."}),(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://xcancel.com/willmcgugan/status/2014341532338606480",children:"- Will McGugan"})})]}),"\n",(0,i.jsxs)(t.admonition,{type:"twitter",children:[(0,i.jsx)(t.p,{children:"We apparently live in the clown universe, where a simple TUI is driven by React and takes 11ms to lay out a few boxes and monospaced text..."}),(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://xcancel.com/its_bvisness/status/2014381220214309042",children:"- Ben Visness"})})]}),"\n",(0,i.jsx)(t.p,{children:"During the storm of criticism, there was at least a little bit of levity:"}),"\n",(0,i.jsxs)(t.admonition,{type:"twitter",children:[(0,i.jsxs)(t.p,{children:["Layout 0.9ms",(0,i.jsx)("br",{}),"\nRasterization 2.1ms",(0,i.jsx)("br",{}),"\nDiffing 1.2ms",(0,i.jsx)("br",{}),"\nBuilding the React scene graph 11.0ms",(0,i.jsx)("br",{}),"\nGenerating ANSI sequences 0.8ms",(0,i.jsx)("br",{}),(0,i.jsx)("br",{})]}),(0,i.jsx)(t.p,{children:"someone who is good at the computer please help me budget this. my small game engine is dying"}),(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://xcancel.com/barrowfaustus/status/2014270514550730867",children:"- barrowfaustus"})})]}),"\n",(0,i.jsx)(t.p,{children:"But many of the responses were even ruder (because some people really get off on being smug and critical on the internet).\nI think there's slightly more to it than that, and the Claude Code team obviously had reasons to go in the direction they did.\nLet's see what there is to learn if we think about the tradeoffs and limitations that they're working with, instead of coming in with another dunk (React? hahaha amirite).\nBefore we generalize to some broader comparison points (React vs Ratatui, garbage collected vs not, interpreted vs compiled), lets start off with some more specific estimates for this type of workload, and why the rebuild around diff-based rendering makes sense."}),"\n",(0,i.jsx)(t.h2,{id:"speed-of-light-text-in-the-terminal",children:"Speed of light (text) in the terminal"}),"\n",(0,i.jsxs)(t.p,{children:['Any terminal interface is fundamentally limited by two things.\nTo understand this, it\'s important to consider the basic pseudoterminal (pty) architecture.\nA program called a "virtual terminal emulator" like iTerm2, Ghostty, VSCode integrated terminal, etc, is used to run or view any terminal process like Claude Code, NetHack, ',(0,i.jsx)(t.code,{children:"cat /dev/urandom"}),', etc.\nTo connect these two, the OS opens up a bidirectional communication channel with a "master" end (the terminal app, what I\'ll call the emulator) and the "slave" end (the foreground process group, what I\'ll call the process).',(0,i.jsx)(t.sup,{children:(0,i.jsx)(t.a,{href:"#user-content-fn-1-41295c",id:"user-content-fnref-1-41295c","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),"\nData sent from the emulator to the process appears as stdin. Conversely, the process writes to stdout and stderr, which the emulator receives and parses to update the display.\nAll of these are byte streams containing a mix of Unicode, ANSI escape sequences, and newer and rarer terminal protocol escape sequences."]}),"\n",(0,i.jsx)(t.p,{children:"So imagine you've built a program that will render a terminal interface.\nBased on the pty architecture, the two limits on the rendering speed are:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["How fast can your program process and respond to new data?\nIncluding ",(0,i.jsx)(t.code,{children:"stdin"})," data like key presses and window resizes, or other data like reading files, network responses, and subprocess results."]}),"\n",(0,i.jsxs)(t.li,{children:["How fast can everything that is ",(0,i.jsx)(t.em,{children:"not"}),' your program, mainly the emulator on the other end, receive and render your output bytestream?\nTechnically the pty communication itself also falls into the "not your program" category and also includes some work (like the line discipline or context switches), but this is nowhere close to the emulator\'s own bottleneck.']}),"\n"]}),"\n",(0,i.jsxs)(t.admonition,{type:"info",children:[(0,i.jsx)(t.p,{children:"Unrelated, but did you know there's an actual hard limit on how many terminal interfaces you can have open?! From the Linux pty manpage:"}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"$ man pty\n...\nThe Linux kernel imposes a limit on the number of available UNIX\n98 pseudoterminals. Up to and including Linux 2.6.3, this limit\nis configured at kernel compilation time (CONFIG_UNIX98_PTYS),\nand the permitted number of pseudoterminals can be up to 2048,\nwith a default setting of 256. Since Linux 2.6.4, the limit is\ndynamically adjustable via /proc/sys/kernel/pty/max, and a\ncorresponding file, /proc/sys/kernel/pty/nr, indicates  how  many\npseudoterminals  are  currently  in  use.\n...\n"})})]}),"\n",(0,i.jsxs)(t.p,{children:["Time for some napkin math.\nImagine we want to rerender as many lines of history as possible: what limits should we expect the bottleneck in the emulator to impose on us?\nLooking at one of my chats, a 150,000 token chat history contains about 53KB of printed text.\nThe full count of tokens would be more like 1MB of text, but the majority of that context contains the thinking tokens (not shown) and the tool calls (truncated), so the output is much smaller.\nHowever, not shown in the raw 53KB of text are the escape codes for colors, bold or dim, and ANSI codes for movement and clearing and printing; altogether this could conceivably double or triple the size in raw bytes.",(0,i.jsx)(t.sup,{children:(0,i.jsx)(t.a,{href:"#user-content-fn-2-41295c",id:"user-content-fnref-2-41295c","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),"\nSo we're looking at something in the low hundreds of KB across the pty connection, for the size of each frame of full history render.\nAssuming a 60 FPS experience, we're looking at ~10MB per second (for example, when an active and updating history cell is just off screen, the frequent cause of Claude Code flicker last year)."]}),"\n",(0,i.jsxs)(t.p,{children:["So how close is this to the theoretical max throughput of the emulator?\nUsing the ",(0,i.jsx)(t.a,{href:"https://github.com/cmuratori/termbench",children:"cmuratori/termbench"})," repo, I can compare a few terminals' max throughput on colored text (see Appendix: Emulator Throughput).\nTo summarize the results from below, modern emulators on modern hardware show result between 30-100MB/s, and legacy emulators are at least an order of magnitude less than that.\nThe GPU-accelerated terminal emulators on my laptop are right around the median of ~50-60MB/s.\nNon-GPU-accelerated terminals (that instead allow synchronous frame drops) show similar throughput.\nThe similarity is unsurprising; the bottleneck doesn't come from the rasterization but from the singly threaded CPU-bound logic to track the state machine of ANSI codes.\nThe variance in my results, at least for the Linux ecosystem, correlates far more with hardware than with the emulator.\nThe built-in terminal versus GPU accelerated terminal on my Mac Mini shows another performance gap: 30MB/s versus 65MB/s.\nI don't have the appetite to benchmark Windows today, but trust me when I say it's generally a cut below the Unix systems.\nFinally, on a raw Linux kernel TTY (e.g. ttyN) without graphical emulation, using minimal device drivers, no GPU acceleration, and no logic for synchronous frame drops, we see the legacy graphics bottleneck: just over 100KB/s.\nNot per frame, per ",(0,i.jsx)(t.em,{children:"second"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["So the napkin math puts us in 10-50MB/s territory for most scenarios, and the dreaded flicker scenario with an updating cell offscreen and a naive reprint requires up to 10MB/s.\nThis doesn't ",(0,i.jsx)(t.em,{children:"fully"})," preclude the possibility of a full history rerender for newer setups, but it's not looking good!\nThese benchmarks show a theoretical maximum that is within the same order of magnitude as the required throughput.\nThis evidence does guarantee the full history rerender will be painful on some legacy terminal emulators or very old hardware, and it will likely introduce frame drops and brief flickers on all but the most optimized setups.\nThe important detail here is that these limitations are ",(0,i.jsx)(t.em,{children:"completely absent any implementation choices of the code itself"}),".\nThis is the maximum speed of the pty architecture, for the requirements the Claude Code team is operating under."]}),"\n",(0,i.jsx)(t.p,{children:"This was the most ignorant part of the critique last week, that lampooned the new architecture.\nI personally question the requirements with the Claude Code team, but to implement those requirements they absolutely need a new architecture like they described.\nGame engine programming is often impressive because after saturating performance bottlenecks in the hardware or OS or another abstraction outside your control, you need to design a smarter approach for your workload.\nIn that light, Thariq's comparison is completely fair."}),"\n",(0,i.jsx)(t.h2,{id:"the-new-architecture",children:"The new architecture"}),"\n",(0,i.jsx)(t.h3,{id:"a-retained-mode-renderer",children:"A retained mode renderer"}),"\n",(0,i.jsxs)(t.p,{children:["The details of their new architecture solve this throughput issue. Rather than forcing entire documents down the pty bottleneck, the new architecture implements the terminal equivalent of a retained mode interface.\nThe emulator retains the screen state between frames, and the program is expected to push down only the minimal ANSI codes to move the cursor (",(0,i.jsx)(t.code,{children:"CUP"}),") and update specific cells.\nAnyone familiar with the Ratatui library knows this pattern. The application still describes the UI every frame, but the new renderer only transmits the changes."]}),"\n",(0,i.jsx)(t.p,{children:"As compared to the React virtual DOM:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"On the Web:"})," DOM updates are slow, so we use VDOM to minimize ",(0,i.jsx)(t.em,{children:"browser repaints"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"In the Terminal:"})," The byte stream is fast, but the ",(0,i.jsx)(t.em,{children:"parsing"})," is the bottleneck."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:'By treating the terminal as a grid of cells rather than a tree of objects, the terminal avoids any "parser jitter."\nHowever, implementing this inside a React-like framework means they are using a nested object tree.\nNot only is this algorithmically more distant from the text grid, it is still creating thousands (tens of thousands?) of short-lived objects per frame to represent that grid of characters.\nThe new design has fixed the I/O bottleneck, but they likely increased the GC pressure, moving the accidental complexity elsewhere.'}),"\n",(0,i.jsx)(t.p,{children:"This leaves us with the remaining, more permanent issue that Claude Code is now dealing with: fighting the framework."}),"\n",(0,i.jsx)(t.h3,{id:"let-history-be-history",children:"Let history be history"}),"\n",(0,i.jsx)(t.p,{children:"Terminal emulators are optimized for two distinct scenarios."}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"The Scrollback"}),": the program turns information over to the emulator to own.\nImmutable, fast, and forgotten by the program.\nThe pty is explicitly optimized for direct copyover of plain Unicode data."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"The Viewport"}),": information fully owned by the app.\nInteractive, temporary, easily customized UI, dynamic rewraps.\nThe altscreen mode offers a separate buffer, fully controlled by the foreground progress (like neovim or Emacs or top).\nLimited height viewports can also be implemented below the history (like ",(0,i.jsx)(t.code,{children:"fzf --inline"}),")."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Claude Code has decided to violate this contract. It decides to treat the ",(0,i.jsx)(t.em,{children:"entire"})," scrollback as a reactive viewport.\nOstensibly, there are some benefits over altscreen: native search (cmd-F or similar), native text selection, native clipboard interactions, or a longer list of multiplexer features.\nBut the cost is fragility."]}),"\n",(0,i.jsxs)(t.p,{children:['When the context gets too long, Claude "compacts" the history.\nIn doing so, it often clears the ',(0,i.jsx)(t.em,{children:"entire"}),' terminal scrollback, including history from before the Claude Code session!\nSimilarly, "fake fullscreen" features (like ctrl+o extended output) rewrite the history instead of using altscreen, so any failure scenario risks a broken scrollback that you can\'t reference or copy from.\nThe most convenient feature is history rewrapping on window resize, and that is gone the moment you quit Claude Code, leaving you with the static history artifact that you were briefly told not to settle for!']}),"\n",(0,i.jsx)(t.h3,{id:"non-pessimization-of-the-requirements",children:"Non-pessimization of the requirements"}),"\n",(0,i.jsxs)(t.p,{children:["Pessimization involves crippling the performance of your program, either by assuming requirements that don't exist, or ignoring constraints that do.\nThere's an attempt here to support an ambitious set of requirements, and I applaud the Claude Code team for pushing boundaries on terminal experiences.\nHowever, every one of the tradeoffs I just described around fragility and fighting the emulator is just not my preference as a user.\nIf I want a scrollable dynamic interface, there is altscreen.\nIf I want a dynamic viewport below longer history, there are normal ",(0,i.jsx)(t.code,{children:"stdout"})," conventions.\nIf I need the rewrapped history, I can ",(0,i.jsx)(t.code,{children:"/resume"})," the conversation in a new window.\nHeck, even introducing a separate ",(0,i.jsx)(t.code,{children:"/rewrap"})," command would make me happier than a system that constantly fights the terminal emulator for custody of the pixels."]}),"\n",(0,i.jsx)(t.p,{children:"In their design, they've pessimized the wrong thing.\nTheir initial requirements assumed that rerendering is free, and responsiveness are paramount.\nThis is incorrect \u2014 the history rerenders have proved to not be free, and I only care about responsiveness in the small section at the bottom that I interact with!"}),"\n",(0,i.jsx)(t.p,{children:"I've found that OpenAI struck a better balance with the Codex CLI design, using a double-buffered history for active vs completed cells.\nIt brings Ratatui performance with diff-based rendering for free, has zero-overhead thread safety, and the raw speed of a non-GC compiled language."}),"\n",(0,i.jsx)(t.p,{children:"Full disclosure (full plug at the end), I've been working on a distant fork of the Codex architecture to wrap the Claude agent and other agent choices.\nIt feels nice using Opus 4.5 without flicker, stuttering, artifacts, or my terminal history getting cleared!"}),"\n",(0,i.jsx)(t.h2,{id:"some-takeaways",children:"Some takeaways"}),"\n",(0,i.jsx)(t.p,{children:"Based on these tidbits from the Claude Code team, I imagine they now have the full diff-based TUI rendering engine built out in TypeScript.\nI don't know in which areas it's at feature parity, superiority, or inferiority with similar frameworks like Ratatui.\nBut having seen the general shape and complexity of code that goes into Ratatui, it is a great milestone for the Claude Code team to deliver their own diff-based engine.\nDespite the immature reactions online, this was definitely a net positive for Claude Code, and puts them much closer to my performance expectations for a cutting-edge TUI.\nWhile I consider the requirements they've inflicted on themselves to be not my personal cup of tea, I appreciate them experimenting with the limitations of interactivity in the terminal."}),"\n",(0,i.jsx)(t.p,{children:"There are a few takeaways I'm left with, if I had to offer my remaining 5c (atop the 95c above):"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Why fight the framework:"})," Every feature that modifies history risks destroying it.\nTerminal users have learned to trust their scrollback as immutable log, and I personally don't like when programs break that trust."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Accidental complexity moves elsewhere:"})," I still question if rendering a text grid via an object tree (DOM/React) is appropriate for an ANSI terminal.\nWith a long chat history, creating or destroying thousands of node objects can easily cause a GC pause, and a frame drop may exhibit a blank screen or partially drawn UI \u2014 more flicker!"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Language tradeoffs:"}),' Interpreted languages often justify the performance hit with "portability."\nBut in the terminal, the "non-standard environments" (Windows, old Unix distros, Android devices, etc) are ',(0,i.jsx)(t.em,{children:"exactly"})," where you need the fastest performance... because they have the slowest emulators!"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Despite the improvements to their architecture, I can't say I would lean on a GC interpreted language like JS for this type of work.",(0,i.jsx)(t.sup,{children:(0,i.jsx)(t.a,{href:"#user-content-fn-3-41295c",id:"user-content-fnref-3-41295c","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"3"})}),"\nClearly they are thinking about some of these concerns, given the acquisition of Bun.\nAnd clearly they are undeterred by the risks, given... The acquisition of Bun.\nI'm impressed by the work within the Bun project to date, and it will be interesting to see what their next chapter within Anthropic looks like.\nAs it relates to Claude Code, this feels kind of like buying more RAM because your program has a memory leak.\nHowever, I have to imagine it's a strategic decision that goes beyond just one product team, and they see a broader need in their portfolio for performant JavaScript runtimes."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsxs)(t.h2,{id:"ps-the-nori-approach",children:["P.S., the ",(0,i.jsx)(t.strong,{children:"Nori"})," Approach"]}),"\n",(0,i.jsxs)(t.p,{children:["If you're interested in these topics, or just want a terminal agent that doesn't flicker, check out the work we're doing at ",(0,i.jsx)(t.a,{href:"https://tilework.tech/",children:(0,i.jsx)(t.strong,{children:"Tilework"})}),"!"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsxs)(t.a,{href:"https://github.com/tilework-tech/nori-cli",children:["Our ",(0,i.jsx)(t.strong,{children:"Nori CLI"})]})," is a distant fork of the Codex CLI, with support for Claude Code.\nWe built this on the philosophy that tools should be fast, intuitive, and respect your terminal's native behavior.\nWe're working on building the things that make us faster at building the things that make us faster, and tools like this are part of our long term vision to help developers fully own (and enjoy) their own toolbox."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"appendix-emulator-throughput",children:"Appendix: Emulator Throughput"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/cmuratori/termbench",children:"Thanks to Casey Muratori's termbench project!"})}),"\n",(0,i.jsxs)(t.p,{children:["These throughputs are explicitly ",(0,i.jsx)(t.em,{children:"not"}),' the output rendered per second;\nthey are the input "accepted" per second.\nBecause of this, they provide a guaranteed max on what your terminal could render out,\nbut do ',(0,i.jsx)(t.em,{children:"not"})," necessarily establish a viable minimum.\nFor example, COSMIC achieves the top result, but actually exhibits long stutters and freezes throughout the benchmark."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"ManyLine:"})," Throughput when printing many short lines."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"LongLine:"})," Throughput when printing long lines wrapping the screen."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"FGPerChar:"})," Throughput when changing foreground color every character."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"FGBGPerChar:"})," Throughput when changing foreground and background color every character."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"TermMarkV2:"})," A balanced benchmark simulating complex terminal usage."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"All numbers in megabytes per second.\nThe laptop environment is running Pop!OS 24.04 with a Ryzen 7 6800U.\nThe desktop environment is running Pop!OS 24.04 with a Ryzen 5 7600X.\nThe Mac Mini environment is running macOS 26.2 with an Apple M4 CPU."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Environment"}),(0,i.jsx)(t.th,{children:"Emulator"}),(0,i.jsx)(t.th,{children:"TermMarkV2"}),(0,i.jsx)(t.th,{children:"ManyLine"}),(0,i.jsx)(t.th,{children:"LongLine"}),(0,i.jsx)(t.th,{children:"FGPerChar"}),(0,i.jsx)(t.th,{children:"FGBGPerChar"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Desktop"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"COSMIC"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"108.8"})}),(0,i.jsx)(t.td,{children:"81.6"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"106.5"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"196.4"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"180.6"})})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Desktop"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Alacritty"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"96.6"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"82.1"})}),(0,i.jsx)(t.td,{children:"89.5"}),(0,i.jsx)(t.td,{children:"140.7"}),(0,i.jsx)(t.td,{children:"136.3"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Laptop"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"COSMIC"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"75.0"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"53.5"})}),(0,i.jsx)(t.td,{children:"77.3"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"142.2"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"127.6"})})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Mac Mini"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Ghostty"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"65.3"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"82.0"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"92.3"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"66.9"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"34.6"})})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Laptop"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Alacritty"})}),(0,i.jsx)(t.td,{children:"65.2"}),(0,i.jsx)(t.td,{children:"49.8"}),(0,i.jsx)(t.td,{children:"63.7"}),(0,i.jsx)(t.td,{children:"113.5"}),(0,i.jsx)(t.td,{children:"103.1"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Desktop"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"GNOME"})}),(0,i.jsx)(t.td,{children:"64.1"}),(0,i.jsx)(t.td,{children:"40.0"}),(0,i.jsx)(t.td,{children:"102.6"}),(0,i.jsx)(t.td,{children:"87.4"}),(0,i.jsx)(t.td,{children:"87.2"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Desktop"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Ghostty"})}),(0,i.jsx)(t.td,{children:"60.0"}),(0,i.jsx)(t.td,{children:"57.2"}),(0,i.jsx)(t.td,{children:"75.4"}),(0,i.jsx)(t.td,{children:"49.1"}),(0,i.jsx)(t.td,{children:"51.7"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Laptop"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"GNOME"})}),(0,i.jsx)(t.td,{children:"56.2"}),(0,i.jsx)(t.td,{children:"34.4"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"101.6"})}),(0,i.jsx)(t.td,{children:"78.7"}),(0,i.jsx)(t.td,{children:"68.4"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Laptop"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Ghostty"})}),(0,i.jsx)(t.td,{children:"53.7"}),(0,i.jsx)(t.td,{children:"55.2"}),(0,i.jsx)(t.td,{children:"77.5"}),(0,i.jsx)(t.td,{children:"35.7"}),(0,i.jsx)(t.td,{children:"40.3"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Mac Mini"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Terminal.app"})}),(0,i.jsx)(t.td,{children:"34.7"}),(0,i.jsx)(t.td,{children:"33.1"}),(0,i.jsx)(t.td,{children:"46.6"}),(0,i.jsx)(t.td,{children:"24.3"}),(0,i.jsx)(t.td,{children:"30.2"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Laptop"}),(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.em,{children:"Virtual tty3"}),"*"]}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.em,{children:"0.3"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.em,{children:"0.2"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.em,{children:"5.0"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.em,{children:"9.0"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.em,{children:"9.1"})})]})]})]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(t.p,{children:["* ",(0,i.jsx)(t.strong,{children:"Virtual tty3"}),": This benchmark ran on a virtual TTY (",(0,i.jsx)(t.code,{children:"/dev/tty3"}),") without a windowing system.\nIt used the ",(0,i.jsx)(t.code,{children:"TermMarkV2 Tiny"})," profile (in order to complete in under 10 minutes), whereas all other emulators used ",(0,i.jsx)(t.code,{children:"TermMarkV2 Normal"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["** ",(0,i.jsx)(t.strong,{children:"Highest Throughput"}),": The highest value for each column within a specific environment is ",(0,i.jsx)(t.strong,{children:"bolded"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n","\n",(0,i.jsxs)(t.section,{"data-footnotes":!0,className:"footnotes",children:[(0,i.jsx)(t.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{id:"user-content-fn-1-41295c",children:["\n",(0,i.jsxs)(t.p,{children:["These are the historical terms used throughout the Unix documentation. I personally find these terms completely unhelpful to remember what the responsibilities here are, so for this user interface centric discussion I'm just referring to the emulator and process group respectively. ",(0,i.jsx)(t.a,{href:"#user-content-fnref-1-41295c","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{id:"user-content-fn-2-41295c",children:["\n",(0,i.jsxs)(t.p,{children:['If you think this is unlikely, see previous, re: "napkin math". ',(0,i.jsx)(t.a,{href:"#user-content-fnref-2-41295c","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{id:"user-content-fn-3-41295c",children:["\n",(0,i.jsxs)(t.p,{children:['When building low-level developer tools, Rust is to me is the much better fit: compile-time thread safety (something something "fearless concurrency"), zero GC, native target optimizations, and indelible boundaries around the unsafe code that necessarily arises with ',(0,i.jsx)(t.code,{children:"libc"})," and ",(0,i.jsx)(t.code,{children:"*nix"})," calls. ",(0,i.jsx)(t.a,{href:"#user-content-fnref-3-41295c","data-footnote-backref":"","aria-label":"Back to reference 3",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);