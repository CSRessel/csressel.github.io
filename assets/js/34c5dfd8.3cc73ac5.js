"use strict";(self.webpackChunkpersonalpage=self.webpackChunkpersonalpage||[]).push([[9024],{4119:e=>{e.exports=JSON.parse('{"permalink":"/blog/agent-is-not-specific","source":"@site/blog/2025-10-26-agent-is-not-specific.md","title":"\\"Agent\\" is a Terribly Non-Specific Term","description":"While there\'s still a chance to throw more terminology at the wall, I think we could do better.","date":"2025-10-26T00:00:00.000Z","tags":[],"readingTime":3.47,"hasTruncateMarker":true,"authors":[{"name":"Clifford","url":"https://github.com/CSRessel","imageURL":"/img/csressel-xs.webp","key":"csressel","page":null}],"frontMatter":{"slug":"agent-is-not-specific","title":"\\"Agent\\" is a Terribly Non-Specific Term","authors":"csressel"},"unlisted":false,"nextItem":{"title":"E Ink tablets: Rooting a Boox Go 10.3","permalink":"/blog/eink-tablet-part1"}}')},8444:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>n,toc:()=>h});var n=o(4119),i=o(4848),s=o(8453);const r={slug:"agent-is-not-specific",title:'"Agent" is a Terribly Non-Specific Term',authors:"csressel"},a=void 0,l={authorsImageUrls:[void 0]},h=[];function c(e){const t={a:"a",code:"code",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"While there's still a chance to throw more terminology at the wall, I think we could do better."}),"\n",(0,i.jsx)(t.p,{children:'I think that there are more specific names we have yet to hit on, for this year\'s applications of generative AI.\nNot only are more specific names possible, they are very useful when communicating between engineers, or coming up with useful specifications for projects. Imagine that every time you wanted to deploy software in 2015, another engineer on your team asked if it was going to "the cloud." Not asking if it\'s going into a Docker container, or running on bare metal on EC2, or using that new tool "kubernetes," but literally asked "hey have you gone to the cloud yet." It would be pretty difficult to have a meaningful engineering conversation about what you\'ve implemented.'}),"\n",(0,i.jsxs)(t.p,{children:['That\'s the way I feel about the word "agent."\n',(0,i.jsx)(t.strong,{children:"Particularly in engineer-to-engineer conversations."}),'\nSo far the only commonality I\'ve seen in the definition of "agent" has been: "thing I trust at least a little bit to do something."\nIt\'s essentially a definition by absentia; if it does anything more than just spit text back at you, call it an agent.\nAs a result, when engineers and founders use this term in a technical context I don\'t get a clearer sense for their concept.']}),"\n",(0,i.jsxs)(t.p,{children:['Here\'s an example of how this could be done better: so-called "coding agents" like Claude Code and Cursor and the rest could be much better termed ',(0,i.jsx)(t.strong,{children:"RETLs: read eval tool loops"}),". This is obviously based on a REPL, which is a read eval print loop. However, in this use case the order of operations is:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Read"}),": user input, previous outputs, MCP for tools, etc; add anything to the prompt or context"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Eval"}),": model inference"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Tool"}),": if the result declares a tool then call it"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Loop"}),": if we haven't declared completion then go to the start"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:'These RETL tools are often put in the category of "synchronous agentic coding." Likewise, there will need to be terminology for architectures in the asynchronous category. In the agentic coding space, these would be the products currently explored by Devin and Factory and similar.'}),"\n",(0,i.jsxs)(t.p,{children:["I've noticed that this second model is architecturally very similar to ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Coroutine",children:"coroutines"}),", where each model is a program, and the suspend/resume is determined by explicit delegation of control to a model, which can ",(0,i.jsx)(t.code,{children:"yield"})," back to the caller, or ",(0,i.jsx)(t.code,{children:"yield from"})," another model or models (or \"sub-agents\"... there's that word again!), or lastly can use another model in a blocking manner.\nBut I'm not the one with the frame of reference to name things in that space, and I certainly don't know the ins and outs of useful terminology that was already coined in the AI research world, like multi-agent systems, agent-based model, ACTOR model, etc."]}),"\n",(0,i.jsxs)(t.p,{children:["However, after working pretty extensively with ",(0,i.jsx)(t.a,{href:"https://opencode.ai/",children:"OpenCode"})," (both as a power user and also to rewrite parts of the tool for my own use) I've noticed that the confines of a very common architectural pattern has emerged around the RETL definition above.\nThe RETL definition isn't just a common trend within the flurry of agentive product releases this year, it's both the necessary and the complete set of behaviors that describe these products!\nAdmittedly for a broad definition of \"tool,\" that encompasses MCP servers and sub-RETLs both."]}),"\n",(0,i.jsx)(t.p,{children:'If there are other terms that fill this gap already, please let me know!\nI\'ve heard of "reflection loops," but that seems to be a prompting technique (equivalent to "self-critique").\nThe most common term I\'ve heard for Cursor/Claude Code/Codex/OpenCode is either "coding tools" or "agentic coding," the first of which fails to distinguish from tab completion and the second of which fails to distinguish from the asynchronous architectures I mentioned above.\nSo in the meantime, I\'ll be name-droppinng RETL to reference these products,  and we\'ll see over time what conensus emerges on the bounds of one architecture vs another.'})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);